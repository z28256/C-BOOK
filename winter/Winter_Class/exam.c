#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
//void reverse(char* left, char* right)
//{
//    while (left < right)
//    {
//        char temp = *left;
//        *left = *right;
//        *right = temp;
//        left++;
//        right--;
//    }
//}
//int main()
//{
//    char str[100] = { 0 };
//    scanf("%[^\n]", str);
//    //gets(str);
//    char* start = str;
//
//    reverse(start, start + strlen(str) - 1);
//    for (int i = 0; i <= strlen(str); i++)
//    {
//        if (str[i] == ' ' || str[i] == '\0')
//        {
//            reverse(start, str + i - 1);
//            start = str + i + 1;
//        }
//    }
//    printf(str);
//    return 0;
//}


//int main()
//{
//    int n1 = 0;
//    int n2 = 0;
//    scanf("%d%d", &n1, &n2);
//    // int max = n1 > n2 ? n1 : n2;
//    // int min = n1 + n2 - max;
//    // int i = 1;     
//    // while (max * i % min)
//    // {
//    //     i++;
//    // }
//    // printf("%d\n", max * i);
//
//    int mod = 0;
//    int mul = n1 * n2;
//    while (mod = n1 % n2)
//    {
//        n1 = n2;
//        n2 = mod;
//    }
//    printf("%d\n", mul / n2);
//    return 0;
//}


//int cnt = 0;
//int fib(int n)
//{
//	cnt++;
//	if (n == 0)
//		return 1;
//	else if (n == 1)
//		return 2;
//	else
//		return fib(n - 1) + fib(n - 2);
//}
////fn=fn-1+fn-2+1
////0 1 2 3 4 5  6  7  8 ...  n
////1 1 3 5 9 15 25 41 67... 
////1 1 2 3 5  8 13 21 34 55
////2: 1   3 : 2   4 :2 + 1 + 1... 
//void main()
//{
//	fib(8);
//	printf("%d\n", cnt);//67
//}


//int main()
//{
//	int x = 1;
//	do {
//		printf("%d\n", x++);
//	} while (x--);
//	return 0;
//}


//int main()
//{
//	int i = 10;
//	int j = 20;
//	int k = 3;
//	k *= i + j;//*=优先级低于+
//	printf("%d\n", k);//90
//	return 0;
//}


//C语言规定，在一个源程序中，main函数的位置可以任意，
//不一定在系统调用的库函数后面

//C语言规定的是语法规则，C语言的标准库由编译器提供
//C语言本身没有输入输出函数，
//不同的编译器提供的输入输出函数功能相同，函数实现不一定也相同

//int main()
//{
//	double x = 2;
//	double y = x + 3 / 2;// 3 / 2 = 1
//	printf("%f\n", y);
//
//	printf("%d\n", 11 | 10);
//	//11 : 1011
//	//10 : 1010
//	//     1011
//
//	return 0;
//}



//数据存储
//char 在VS2022默认是signed char,signed / unsigned取决于不同编译器

//构造类型
//数组  int[10] char[5]  结构体 struct 联合体 union 枚举 enum

//int main()
//{
//	int n1 = 5;
//	//00000000 00000000 00000000 00000101  补码
//	//0x00 00 00 05
//	int n2 = -5;
//	//10000000 00000000 00000000 00000101
//	//11111111 11111111 11111111 11111010
//	//11111111 11111111 11111111 11111011 补码
//	//0xff ff ff fb
//	//内存中实际存储的是0xfb ff ff ff（小端）
//	printf("%x\n", n2);
//	return 0;
//}


//整型为什么在内存中存储补码?
//将符号位与数值域统一处理；
//加减法也可以统一处理（CPU只有加法器），
//补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路


//大小端字节序
//大端：数据的低（高）位存储在内存的高（低）地址处
//小端：数据的低（高）位存储在内存的低（高）地址处


//判断大小端?
//int main()
//{
//	int a = 1;
//	if (*(char*)&a)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}


//int main()
//{
//	char a = -1;
//	//11111111 11111111 11111111 11111111 === -1
//	//截断 11111111 a
//	signed char b = -1;
//	unsigned char c = -1;
//	//11111111  
//	printf("%d %d %d\n", a, b, c);//-1 -1 255
//	//整型提升 
//	//a:signed char 11111111 11111111 11111111 11111111    //-1
//	//c:unsigned char 00000000 00000000 00000000 11111111  //255
//	return 0;
//}


//int main()
//{
//	char a = -128;
//	//10000000 00000000 00000000 10000000
//	//11111111 11111111 11111111 01111111
//	//11111111 11111111 11111111 10000000
//	
//	//截断 10000000
//	printf("%u\n", a);//直接打印  4294967168
//	printf("%d\n", a);//-128
//	//a signed char:11111111 11111111 11111111 10000000
//	return 0;
//}


//int main()
//{
//	char a = 128;
//	//00000000 00000000 00000000 10000000
//	//10000000
//	printf("%u\n", a);//4294967168
//	printf("%d\n", a);//-128
//	//11111111 11111111 11111111 10000000
//	return 0;
//}


//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);//-10
//	printf("%u\n", i + j);
//	printf("%x\n", i + j);//0xff ff ff f6
//	//10000000 00000000 00000000 00010100  -20
//	//11111111 11111111 11111111 11101011
//	//
//	//11111111 11111111 11111111 11101100  补码
//	//00000000 00000000 00000000 00001010  10
//	//---------------------------------------- 
//	//11111111 11111111 11111111 11110110   //0xff ff ff f6
//	//10000000 00000000 00000000 00001001
//	//10000000 00000000 00000000 00001010  -10
//
//	return 0;
//}


#include <Windows.h>
//int main()
//{
//	unsigned int i;//i恒大于等于0
//	for (i = 9; i >= 0; i--)//死循环
//	{
//		printf("%u\n", i);
//		Sleep(200);
//	}
//	return 0;
//}


//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//		//-1 -2 -3 ...-128 127 ...1 0
//	}
//	printf("%zd", strlen(a));//128 + 127
//	return 0;
//}


//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)//死循环
//	{
//		printf("%d: hello world\n", i);
//		Sleep(20);
//	}
//	return 0;
//}


//整形的取值范围: limits.h
//浮点数的取值范围: float.h


//(-1)^S * M * 2^E
//S:0/1   M:1.xxxxxx(只保存0后面的)
//float: E: 8位0 ~ 255（没有原码反码补码，只表示正数）将次方数加127表示

//5.5
//101.1  (-1)^0 * 1.011 * 2^2 E:2+127=129 
//0 10000001 01100000000000000000000
//01000000 10110000 00000000 00000000
//0x40 b0 00 00

//0.5
//0.1 (-1)^0 * 1.000... * 2^(-1)
//0 01111110 00000000000000000000000
//00111111 00000000 00000000 00000000
//0x3f 00 00 00
//int main()
//{
//	float f = 5.5f;
//	printf("%x\n", *(int*)&f);//40b00000
//	float f1 = 0.5f;
//	printf("%x\n", *(int*)&f1);//3f000000
//
//	return 0;
//}


//取出
//E全为0  
//浮点数float的指数E等于-126 此时将 M 还原为0.xxxxxx的小数，表示接近0的数

//E全为1
//浮点数float的指数E等于128 此时如果 M 为0，表示 +- 无穷大（ +- 取决于符号位 s）


//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n;
//	printf("n的值为：%d\n", n);//9
//	printf("*pFloat的值为：%f\n", *pFloat);//0.000000
//	//00000000 00000000 00000000 00001001
//	//0 00000000 00000000000000000001001
//	//(-1)^0 * 0.00000000000000000001001 * 2^(-127)
//	*pFloat = 9.0;
//	//1001.0
//	//(-1)^0 * 1.001 * 2^3
//	//0 10000010 00100000000000000000000
//	//01000001 00010000 00000000 00000000
//	//0x41 10 00 00
//	printf("num的值为：%d\n", n);//1091567616
//	printf("num的值为：%x\n", n);//0x41 10 00 00
//	printf("*pFloat的值为：%f\n", *pFloat);//9.000000
//
//	return 0;
//}

















